# Custom Zsh Prompt
#
# DESCRIPTION:
#   A minimal, context-aware Zsh prompt that displays only relevant information.
#
# FEATURES:
#   - Shows the full path when outside Git, and path relative to repo root when inside.
#   - Displays Git branch name or status (main/master, rebase, detached), with colors.
#   - Shows prompt symbol based on context:
#       â€¢ '$' for regular users
#       â€¢ '#' for root
#       â€¢ â¬¢ (magenta) for Distrobox containers
#       â€¢ â¬¢ (blue) for Docker/Podman containers
#   - Changes the prompt symbol to red on non-zero exit codes.
#   - Shows `user@host` when connected via SSH, or username if not `luke`.
#   - Caches Git info per directory for performance.
#   - Omits spacing between prompt elements when not needed.

# ========== SSH and User Display ==========
show_user_host() {
  if [[ -n $SSH_CLIENT || -n $SSH_CONNECTION || -n $SSH_TTY ]]; then
    echo "%F{cyan}${USER}@${HOST}%f "
  else
    if [[ "$USER" != "luke" ]]; then
      echo "%F{cyan}${USER}%f "
    fi
  fi
}

# ========== Git Prompt Cache ==========
typeset -g __GIT_INFO_CACHE_DIR=""
typeset -g __GIT_INFO_CACHE_STR=""

# --- ADDED: Clear cache on directory change ---
autoload -Uz add-zsh-hook
clear_git_cache() {
  __GIT_INFO_CACHE_DIR=""
  __GIT_INFO_CACHE_STR=""
}
add-zsh-hook chpwd clear_git_cache

# ========== Git Path Info ==========
git_info_path() {
  local toplevel repo branch relpath color

  # Guard: exit early if git is not installed
  if ! command -v git >/dev/null 2>&1; then
    echo "%F{245}${PWD/#$HOME/~}%f"
    return
  fi

  # Return cached result if same directory
  if [[ "$PWD" == "$__GIT_INFO_CACHE_DIR" && -n "$__GIT_INFO_CACHE_STR" ]]; then
    echo "$__GIT_INFO_CACHE_STR"
    return
  fi

  if toplevel=$(git rev-parse --show-toplevel 2>/dev/null); then
    repo=${toplevel:t}
    if git rev-parse --abbrev-ref HEAD 2>/dev/null | grep -qv '^HEAD$'; then
      branch=$(git symbolic-ref --short HEAD 2>/dev/null)
      if [[ $branch == "main" || $branch == "master" ]]; then
        color="yellow"
      else
        color="green"
      fi
      if [[ -d "$toplevel/.git/rebase-merge" || -d "$toplevel/.git/rebase-apply" ]]; then
        branch="REBASE"
        color="red"
      fi
    else
      branch="DETACHED"
      color="red"
    fi
    relpath="${PWD#$toplevel}"
    relpath="${relpath#/}"

    local dirty_flags=$(git_dirty_status)
    local group="%F{245}${repo}%f%F{245}:%f%F{$color}${branch}%f${dirty_flags}"
    if [[ -n $relpath ]]; then
      __GIT_INFO_CACHE_STR="${group}%F{245}/${relpath}%f"
    else
      __GIT_INFO_CACHE_STR="${group}"
    fi
  else
    __GIT_INFO_CACHE_STR="%F{245}${PWD/#$HOME/~}%f"
  fi

  __GIT_INFO_CACHE_DIR="$PWD"
  echo "$__GIT_INFO_CACHE_STR"
}


# ========== Git porcelain status ==========
git_dirty_status() {
  # Only run if inside a git repo
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    return
  fi

  local git_status staged untracked dirty flags=""
  # Get short porcelain status to speed up
  git_status=$(git status --porcelain 2>/dev/null)

  # Check staged files (lines starting with A, M, D, R, C in index)
  if echo "$git_status" | grep -qE '^[AMDRC]'; then
    staged="+"
  fi

  # Check untracked files (lines starting with ??)
  if echo "$git_status" | grep -q '^??'; then
    untracked="?"
  fi

  # Check modified but unstaged files (lines starting with ' ' in index, but changed in work tree)
  if echo "$git_status" | grep -qE '^.[MD]'; then
    dirty="*"
  fi

  # Combine flags in order: staged, dirty, untracked
  flags="${staged}${dirty}${untracked}"

  # Output with color (yellow) if any flags present
  if [[ -n $flags ]]; then
    echo "%F{yellow}${flags}%f"
  fi
}


# OPTIONAL: Compress deep paths like fish shell (disabled by default)
# compress_path() {
#   local max=3
#   local path=${1:-$PWD}
#   local parts=(${(s:/:)path})
#   local len=${#parts[@]}
#   if (( len > max )); then
#     echo "~/${parts[1]}/â€¦/${parts[-1]}"
#   else
#     echo "${path/#$HOME/~}"
#   fi
# }

# ========== Container Display ==========
container_indicator() {
  if [[ -e /run/.containerenv ]]; then
    if [[ -n $DISTROBOX_ENTER_PATH || -n $container ]]; then
      echo " %F{magenta}ï†²%f"
    else
      echo " %F{33}ïŒˆ%f"
    fi
  fi
}

# ========== Optional Short Names ==========
short_user() {
  case "$USER" in
    root) echo "ro" ;;
    admin) echo "ad" ;;
    docker) echo "do" ;;
    luke) echo "lk" ;;
    *) echo "${USER:0:2}" ;;
  esac
}

short_host() {
  case "$HOST" in
    bluefin) echo "bf" ;;
    polar) echo "polar" ;;
    workbook) echo "work" ;;
    macbook) echo "mac" ;;
    *) echo "${HOST:0:2}" ;;
  esac
}

show_ssh_host() {
  if [[ -n $SSH_CLIENT || -n $SSH_CONNECTION || -n $SSH_TTY ]]; then
    short_host
  fi
}

# ========== Exit Code Indicator ==========
# Store last command exit code before the prompt is drawn
typeset -g LAST_EXIT_CODE=0

autoload -Uz add-zsh-hook
add-zsh-hook precmd update_last_exit_code

update_last_exit_code() {
  LAST_EXIT_CODE=$?
}

# ========== Prompt Symbol ==========
prompt_symbol() {
  local symbol color

  if [[ -n $DISTROBOX_ENTER_PATH || -n $container ]]; then
    symbol='â¬¢'
    color='magenta'
  elif [[ -e /run/.containerenv ]]; then
    symbol='â¬¢'
    color='blue'
  elif [ "$EUID" -eq 0 ]; then
    symbol='#'
    color='red'
  else
    symbol='$'
    color='white'
  fi

  # ðŸ”´ Error indicator: override with red if previous command failed
  if (( LAST_EXIT_CODE != 0 )); then
    color='red'
  fi

  echo "%F{$color}${symbol}%f"
}

# ========== Add conditional spacing =========
spaced() {
  local part="$($1)"
  [[ -n $part ]] && echo " $part"
}

# ========== Enable Prompt Substitution ==========
setopt PROMPT_SUBST

# ========== Final Prompt ==========
PS1='$(spaced show_user_host)$(git_info_path)$(spaced prompt_symbol) '

